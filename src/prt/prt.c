#include "global.h"
#include "uart.h"
#include "prt.h"
#include <string.h>
#include "esc2bmp.h"
#include "net.h"
#include <dirent.h>
#include "cJSON.h"
#include <time.h>

esc2bmp_handle_t prt_handle;

unsigned char test_cmd[] = { 0x1b, 0x1b, 0x52, 0x45, 0x43, 0x45, 0x49, 0x56, 0x45, 0x0d, 0x0a, 0x55, 0x49, 0x44, 0x3a, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x38, 0x33, 0x33, 0x30, 0x30, 0x30, 0x32, 0x0d, 0x0a, 0x50, 0x49, 0x44, 0x3a, 0x5b, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x38, 0x33, 0x33, 0x30, 0x30, 0x30, 0x32, 0x5d, 0x0d, 0x0a, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x5f, 0x69, 0x64, 0x78, 0x3a, 0x30, 0x30, 0x30, 0x31, 0x0d, 0x0a, 0x1b, 0x40, 0x1b, 0x70, 0x00, 0x32, 0x7d, 0x1d, 0x21, 0x00, 0x1b, 0x61, 0x01, 0x1b, 0x33, 0x1e, 0x1b, 0x61, 0x01, 0x49, 0x6e, 0x64, 0x6f, 0x63, 0x68, 0x61, 0x74, 0x0a, 0x0a, 0x1b, 0x61, 0x00, 0x44, 0x69, 0x6e, 0x65, 0x20, 0x49, 0x6e, 0x0a, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x31, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x47, 0x75, 0x65, 0x73, 0x74, 0x20, 0x31, 0x0a, 0x52, 0x65, 0x63, 0x65, 0x69, 0x70, 0x74, 0x20, 0x23, 0x20, 0x3a, 0x20, 0x32, 0x30, 0x30, 0x39, 0x30, 0x30, 0x30, 0x30, 0x30, 0x33, 0x0a, 0x44, 0x61, 0x74, 0x65, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3a, 0x20, 0x32, 0x30, 0x32, 0x30, 0x2d, 0x30, 0x39, 0x2d, 0x30, 0x32, 0x20, 0x31, 0x36, 0x3a, 0x32, 0x34, 0x3a, 0x34, 0x31, 0x0a, 0x53, 0x74, 0x61, 0x66, 0x66, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3a, 0x20, 0x4d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x72, 0x0a, 0x1d, 0x21, 0x01, 0x1b, 0x61, 0x01, 0x43, 0x4f, 0x50, 0x59, 0x20, 0x52, 0x45, 0x43, 0x45, 0x49, 0x50, 0x54, 0x1d, 0x21, 0x00, 0x0a, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x0a, 0x1b, 0x33, 0x1e, 0x1b, 0x61, 0x00, 0x33, 0x20, 0x78, 0x20, 0x35, 0x30, 0x2c, 0x30, 0x30, 0x30, 0x0a, 0x6b, 0x6f, 0x70, 0x69, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x31, 0x35, 0x30, 0x2c, 0x30, 0x30, 0x30, 0x0a, 0x0a, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x0a, 0x1b, 0x33, 0x1e, 0x53, 0x55, 0x42, 0x54, 0x4f, 0x54, 0x41, 0x4c, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x31, 0x35, 0x30, 0x2e, 0x30, 0x30, 0x30, 0x0a, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x20, 0x43, 0x68, 0x61, 0x72, 0x67, 0x65, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x30, 0x0a, 0x54, 0x41, 0x58, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x31, 0x35, 0x2e, 0x30, 0x30, 0x30, 0x0a, 0x52, 0x6f, 0x75, 0x6e, 0x64, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x30, 0x0a, 0x1d, 0x21, 0x01, 0x54, 0x4f, 0x54, 0x41, 0x4c, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x31, 0x36, 0x35, 0x2e, 0x30, 0x30, 0x30, 0x0a, 0x1d, 0x21, 0x00, 0x50, 0x61, 0x79, 0x6d, 0x65, 0x6e, 0x74, 0x20, 0x28, 0x43, 0x61, 0x73, 0x68, 0x29, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x31, 0x36, 0x35, 0x2e, 0x30, 0x30, 0x30, 0x0a, 0x43, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x30, 0x0a, 0x1b, 0x61, 0x01, 0x1b, 0x61, 0x01, 0x0a, 0x54, 0x68, 0x61, 0x6e, 0x6b, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x79, 0x6f, 0x75, 0x72, 0x20, 0x76, 0x69, 0x73, 0x69, 0x74, 0x0a, 0x0a, 0x1b, 0x61, 0x01, 0x50, 0x6f, 0x77, 0x65, 0x72, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x77, 0x77, 0x77, 0x2e, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x62, 0x69, 0x6c, 0x6c, 0x2e, 0x69, 0x64, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x1b, 0x69, 0x1b, 0x1b, 0x52, 0x45, 0x43, 0x45, 0x4e, 0x44, 0x0d, 0x0a};
unsigned char prt_data[] = {0x1B, 0x40, 0x1B, 0x70, 0x00, 0x32, 0x7D, 0x1D, 0x21, 0x00, 0x1B, 0x61, 0x01, 0x1B, 0x33, 0x1E, 0x1B, 0x61, 0x01, 0x49, 0x6E, 0x64, 0x6F, 0x63, 0x68, 0x61, 0x74, 0x0A, 0x0A, 0x1B, 0x61, 0x00, 0x54, 0x61, 0x6B, 0x65, 0x20, 0x41, 0x77, 0x61, 0x79, 0x0A, 0x52, 0x65, 0x63, 0x65, 0x69, 0x70, 0x74, 0x20, 0x23, 0x20, 0x3A, 0x20, 0x32, 0x30, 0x31, 0x31, 0x30, 0x30, 0x30, 0x33, 0x35, 0x39, 0x0A, 0x44, 0x61, 0x74, 0x65, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3A, 0x20, 0x32, 0x30, 0x32, 0x30, 0x2D, 0x31, 0x32, 0x2D, 0x30, 0x33, 0x20, 0x31, 0x31, 0x3A, 0x30, 0x32, 0x3A, 0x30, 0x33, 0x0A, 0x53, 0x74, 0x61, 0x66, 0x66, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3A, 0x20, 0x4D, 0x61, 0x6E, 0x61, 0x67, 0x65, 0x72, 0x0A, 0x1D, 0x21, 0x01, 0x1B, 0x61, 0x01, 0x43, 0x4F, 0x50, 0x59, 0x20, 0x52, 0x45, 0x43, 0x45, 0x49, 0x50, 0x54, 0x1D, 0x21, 0x00, 0x0A, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x0A, 0x1B, 0x33, 0x1E, 0x1B, 0x61, 0x00, 0x31, 0x20, 0x78, 0x20, 0x35, 0x2C, 0x30, 0x30, 0x30, 0x0A, 0x46, 0x6F, 0x6F, 0x64, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x35, 0x2C, 0x30, 0x30, 0x30, 0x0A, 0x0A, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x0A, 0x1B, 0x33, 0x1E, 0x53, 0x55, 0x42, 0x54, 0x4F, 0x54, 0x41, 0x4C, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x35, 0x2E, 0x30, 0x30, 0x30, 0x0A, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x20, 0x43, 0x68, 0x61, 0x72, 0x67, 0x65, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x30, 0x0A, 0x54, 0x41, 0x58, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x35, 0x30, 0x30, 0x0A, 0x52, 0x6F, 0x75, 0x6E, 0x64, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x30, 0x0A, 0x1D, 0x21, 0x01, 0x54, 0x4F, 0x54, 0x41, 0x4C, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x35, 0x2E, 0x35, 0x30, 0x30, 0x0A, 0x1D, 0x21, 0x00, 0x50, 0x61, 0x79, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x28, 0x43, 0x61, 0x73, 0x68, 0x29, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x35, 0x30, 0x2E, 0x30, 0x30, 0x30, 0x0A, 0x43, 0x68, 0x61, 0x6E, 0x67, 0x65, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x34, 0x34, 0x2E, 0x35, 0x30, 0x30, 0x0A, 0x1B, 0x61, 0x01, 0x1B, 0x61, 0x01, 0x0A, 0x54, 0x68, 0x61, 0x6E, 0x6B, 0x20, 0x79, 0x6F, 0x75, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x79, 0x6F, 0x75, 0x72, 0x20, 0x76, 0x69, 0x73, 0x69, 0x74, 0x0A, 0x0A, 0x1B, 0x61, 0x01, 0x50, 0x6F, 0x77, 0x65, 0x72, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x77, 0x77, 0x77, 0x2E, 0x68, 0x65, 0x6C, 0x6C, 0x6F, 0x62, 0x69, 0x6C, 0x6C, 0x2E, 0x69, 0x64, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x1B, 0x69};


static prt_net_data usb_prt_buf;

unsigned int usb_data_cb(void *buff, unsigned int size)
{
    int i = 0, j = 0;
    unsigned char ctrl_upload_flag = 0;
    //static unsigned int buff_index = 0;
    char ret_buff[512] = {0};
    FILE *fp;


    print_array(buff, size);

    memcpy(usb_prt_buf.data + (usb_prt_buf.len), buff, size);
    usb_prt_buf.len += size;

    //printf("buff_index = %d, size = %d\n", buff_index, size);
    //memcpy(&pn_data_buf.data[buff_index], buff, size);
    //buff_index += size;

    if(usb_prt_buf.len > 20)
    {
        create_node(usb_prt_buf.data, usb_prt_buf.len);
        usb_prt_buf.len = 0;
    //     if(pn_data.data[buff_index - 3] == 0x1d && pn_data.data[buff_index - 2] == 0x56 && pn_data.data[buff_index - 1] == 0x01)
    //     {
    //         printf("only 1d5601\n");
    //         prt_handle.esc_2_prt(pn_data.data, (buff_index - 3));
    //         pn_data.len = 0;
    //         prt_handle.printer_cut(96);
    //         buff_index = 0;
    //         printf("only prt end 4, prt data 2\n");               
    //     }
    //     else
    //     {
    //         //if(pn_data.data[buff_index - 4] == 0x70 && pn_data.data[buff_index - 5] == 0x1b)
    //        // {
    //             printf("start combine data3!\n");
    //             memcpy(&pn_data.data[buff_index - 8], &pn_data.data[buff_index - 5], 5);
    //             pn_data.len = buff_index - 3;
    //             buff_index = 0;     
    //             for(j = 0; j < pn_data.len; j++)
    //             {   
    //                 printf("%c", pn_data.data[j]);
    //                 if(strncmp(&pn_data.data[j], "Scan Kode Sid9", strlen("Scan Kode Sid9")) == 0)
    //                 {
    //                     printf("need printf3!\n");
    //                     ctrl_upload_flag = 1;
    //                     break;
    //                 }
    //             }
    //             if(ctrl_upload_flag == 1)
    //             {
    //                 ctrl_upload_flag = 0;
    //                 fp = popen("rm ./escode/code.bin", "r");
    //                 if(fp != NULL)
    //                 {
    //                     while(fgets(ret_buff, sizeof(ret_buff), fp) != NULL)
    //                     {
    //                         if('\n' == ret_buff[strlen(ret_buff)-1])
    //                         {
    //                             ret_buff[strlen(ret_buff)-1] = '\0';
    //                         }
    //                         printf("rm ./escode/code.bin = %s\r\n", ret_buff);
    //                     }
    //                     pclose(fp);
    //                 }
    //                 else
    //                 {
    //                     printf("popen faild!!!!!!!!!!\n");
    //                 }
    //                 //system("rm ./escode/code.bin");
    //                 dump_data("./escode/code.bin", pn_data.data, pn_data.len);
    //                 fp = popen("rm ./escode/upload.zip", "r");
    //                 if(fp != NULL)
    //                 {
    //                     while(fgets(ret_buff, sizeof(ret_buff), fp) != NULL)
    //                     {
    //                         if('\n' == ret_buff[strlen(ret_buff)-1])
    //                         {
    //                             ret_buff[strlen(ret_buff)-1] = '\0';
    //                         }
    //                         printf("rm ./escode/upload.zip = %s\r\n", ret_buff);
    //                     }
    //                     pclose(fp);
    //                 }
    //                 else
    //                 {
    //                     printf("popen faild!!!!!!!!!!\n");
    //                 }
    //                 fp = popen("zip -r ./escode/upload.zip ./escode/*", "r");
    //                 if(fp != NULL)
    //                 {
    //                     while(fgets(ret_buff, sizeof(ret_buff), fp) != NULL)
    //                     {
    //                         if('\n' == ret_buff[strlen(ret_buff)-1])
    //                         {
    //                             ret_buff[strlen(ret_buff)-1] = '\0';
    //                         }
    //                         printf("zip = %s\r\n", ret_buff);
    //                     }
    //                     pclose(fp);
    //                 }
    //                 else
    //                 {
    //                     printf("popen faild!!!!!!!!!!\n");
    //                 }            
    //                 g_upload_flag = 1;  
    //             }
    //             else
    //             {
    //                 prt_handle.esc_2_prt(pn_data.data, pn_data.len);
    //                 pn_data.len = 0;
    //                 prt_handle.printer_cut(96);
    //                 i = 0;
    //                 printf("only prt end 5, prt data 3\n");                    
    //             }                
    //         //}
    //     }

    }


	//printf("usb %d bytes %.*s\n", size, size, buff);
}
void bmp_cb(const char *bmp_path)
{
    FILE *fp;
    char ret_buff[128] = {0};
    printf("function %s was called\n", __FUNCTION__);
	printf("bmp_path = %s\n", bmp_path);
	// if (prt_handle.bmp_print) {
	// 	printf("start print bmp!\n");
	// 	prt_handle.bmp_print(bmp_path);
	// 	prt_handle.printer_cut(8);
	// }

    fp = popen("rm ./escode/upload.zip", "r");
    if(fp != NULL)
    {
        while(fgets(ret_buff, sizeof(ret_buff), fp) != NULL)
        {
            if('\n' == ret_buff[strlen(ret_buff)-1])
            {
                ret_buff[strlen(ret_buff)-1] = '\0';
            }
            printf("rm ./escode/upload.zip = %s\r\n", ret_buff);
        }
        pclose(fp);                   
    }
    fp = popen("zip -r ./escode/upload.zip ./escode/*", "r");
    if(fp != NULL)
    {
        while(fgets(ret_buff, sizeof(ret_buff), fp) != NULL)
        {
            if('\n' == ret_buff[strlen(ret_buff)-1])
            {
                ret_buff[strlen(ret_buff)-1] = '\0';
            }
            printf("zip = %s\r\n", ret_buff);
        }
        pclose(fp);                   
    }
    g_upload_flag = 1;
}

void prt_init (void)
{

    char sn_buff[64] = {0};
    unsigned char test_feed[3] = {0x1b, 0x64, 0x06};
    unsigned char test_cut[4] = {0x1d, 0x56, 0x42, 0x40};
    unsigned char drawer_cmd[5] = {0x1b, 0x70, 0x30, 0x37, 0x79};
    unsigned char drawer_cmd1[5] = {0x10, 0x14, 0x00, 0x00, 0x00};
    char *prt_str = "INIT OK!\n";
    printf ("prt_init \n");
    char bmp_path[] = "/smart9/escode/100000000018330045_100000000018330045_0017.bmp";
    char f_path[] = "/oem/fonts_gb18030.bin";
    memset(&prt_handle, 0, sizeof(prt_handle));

    strcpy(prt_handle.font_path, f_path);
    prt_handle.bmp_callback = bmp_cb;
	prt_handle.usb_data_cb = usb_data_cb;
    //strcpy(prt_handle.bmp_path, bmp_path);
	esc2bmp_version_print();
    printf("start init!\n");
    if (esc2bmp_init(&prt_handle)) {
		printf("Initial failed!!!\n");
		exit(1);
	}
    printf("init success!\n");

    prt_handle.get_printer_sn(sn_buff, 64);

    printf(" sn is %s\n", sn_buff);
    usb_prt_buf.len = 0;
    memset(usb_prt_buf.data, 0, sizeof(usb_prt_buf.data));

    // prt_handle.esc_2_prt(drawer_cmd, 5);

    // while(1);


    //prt_handle.esc_2_prt(prt_str, 10);
    //prt_handle.printer_cut(96);
    // while(1)
    // {
    //     prt_handle.esc_2_prt(prt_data, sizeof(prt_data));
    //     sleep(10);
    // }


}

void prt_print (unsigned char* data, int len)
{
   printf ("start prt_print! \n");
   uart_write (data, len);
}

int escpos_printer_feed( const int lines)
{


    char buffer[3];
    strncpy(buffer, ESCPOS_CMD_FEED, 2);
    buffer[2] = lines;
    uart_write (buffer, sizeof(buffer));
    return 0;
}

int escpos_printer_cut(const int lines)
{
    char buffer[4];
    strncpy(buffer, ESCPOS_CMD_CUT1, 3);
    buffer[3] = lines;
    uart_write (buffer, sizeof(buffer));
    return 0;
}


extern void lib_event_callback(hprt_lib_event_t e, const void *arg, unsigned int size)
{
    volatile static unsigned char re_prt_flag = 0;
    unsigned char tmp_data = 0;
    printf("callback id = %d, size = %d, data is:\n", e, size);
    print_array(arg, size);
    switch(e)
    {
        case HPRT_LIB_EVENT_STATUS:
            tmp_data = *(unsigned char *)arg;
            if(((tmp_data >> 2) & 0x01) == 0x01)
            {
                printf("prt open!\n");
                re_prt_flag = 1;
            }
            if(((tmp_data >> 2) & 0x01) == 0x00)
            {
                printf("prt close!\n");
                g_printing_flag = true;
                prt_handle.esc_2_prt(pn_buf.data, pn_buf.len);
                prt_handle.printer_cut(196);
                //prt_handle.printer_cut(84);
                printf("prt data 4\n");
                //prt_handle.push_printer_process_id(0x01);
                // memset(pn_data.data, 0x00, pn_data.len);
                // pn_data.len = 0;
                re_prt_flag = 0;
                g_printing_flag = false;
            }
        break;

        case HPRT_LIB_EVENT_ID_RET:
            // memset(pn_data.data, 0x00, pn_data.len);
            // pn_data.len = 0;
        break;

        case HPRT_LIB_EVENT_PRINTER_ID_RET:
            if(re_prt_flag == 0x00)
            {

            }
        break;


    }
}

unsigned char get_offline_code(void)
{
    DIR * dp;
    int i = 0;
    struct dirent *filename;    
    int32_t len;
    int file_name_index;
    unsigned int min_num = 5000;
    char tmp_str[32] = {0};
    char code_dir[64] = {0};
    char dir[64] = "/oem/offline_code/";
    char code_name_str[] = "/codedata.bin";
    char mkdir_str[64] = "mkdir /oem/offline_data/";
    char cp_info[64] = "cp /oem/config/info.json /oem/offline_data/";
    char cp_zip[64] = "cp /oem/escode/upload.zip /oem/offline_data/";
    char info_json[64] = "/oem/offline_data/";
    char info_name_str[64] = {0};
    char rm_str[64] = "rm ";
    unsigned char info_text[64] = {0};
    unsigned int file_count = 0;

    dp = opendir("/oem/offline_code");
    if(dp != NULL)
    {
        while (filename = readdir(dp))
        {
            file_count++;
            //printf("filename:%-10s\t\n",filename->d_name);
            file_name_index = atoi(filename->d_name);
            //printf("name index = %d\n", file_name_index);
            if(file_name_index < min_num && file_name_index != 0x00)
            {
                min_num = file_name_index;
                strcpy(code_dir, filename->d_name);
            }
        }   
        printf("file count = %d\n", file_count); 
        if(file_count == 0x02)
            return 1;
    }
    closedir(dp);
    printf("code dir is: %s\n", code_dir);
    strcpy(&dir[strlen(dir)], code_dir);
    strcpy(&rm_str[strlen(rm_str)], dir);
    strcpy(&rm_str[strlen(rm_str)], " -r");
    printf("rm_str = %s\n", rm_str);
    strcpy(info_name_str, dir);
    strcpy(&info_name_str[strlen(info_name_str)], "/info.txt");
    printf("info_name_str = %s\n", info_name_str);
    load_data(info_name_str, info_text, &len);
    printf("info_text = %s\n", info_text);
    strcpy(&dir[strlen(dir)], code_name_str);
    printf("dir is: %s\n", dir);

    printf("pos data len = %d\n", pn_data.len);
    print_array(&pn_data.data[0], pn_data.len);
    load_data(dir, &pn_data.data[pn_data.len], &len);
    printf("offline data len = %d\n", len);
    print_array(&pn_data.data[pn_data.len], len);
    pn_data.len += (len - 2);

    min_num = 0;
    memset(code_dir, 0, sizeof(code_dir));
    dp = opendir("./offline_data");
    if(dp != NULL)
    {
        while (filename = readdir(dp))
        {
            //printf("filename:%-10s\t\n",filename->d_name);
            file_name_index = atoi(filename->d_name);
            //printf("name index = %d\n", file_name_index);
            if(file_name_index > min_num)
            {
                min_num = file_name_index;
            }
        }    
        min_num++;
        sprintf(tmp_str, "%d", min_num);
        strcpy(&info_json[strlen(info_json)], tmp_str);
        strcpy(&info_json[strlen(info_json)], "/info.json");
        strcpy(&mkdir_str[strlen(mkdir_str)], tmp_str);
        strcpy(&cp_info[strlen(cp_info)], tmp_str);
        strcpy(&cp_zip[strlen(cp_zip)], tmp_str);
        printf("mkdir str is: %s\n", mkdir_str);
        printf("cpinfo str is: %s\n", cp_info);
        printf("cpzip str is: %s\n", cp_zip);
    }
    system_op(mkdir_str);
    system_op(cp_info);
    system_op(cp_zip);

    printf("info json dir is: %s\n", info_json);
    updata_offine_json(info_json, info_text);


    system_op(rm_str);
    system_op("sync");    

    return 0;
}

void updata_offine_json(char *json_str, char *code_id)
{
    cJSON *json = NULL;
    cJSON *data_time = NULL;
    unsigned int len = 0;
    unsigned char json_buf[2048] = {0};    
    struct timeval tv;
    char tmp_buf[64] = {0};


    load_data(json_str, json_buf, &len);
    printf("info_json is: %s\n", json_buf);
    json = cJSON_Parse(json_buf);
    if(!json)
    {
        printf("ERROR before: [%s]\n", cJSON_GetErrorPtr());
    }

    gettimeofday (&tv, NULL);
    printf("tv_sec; %d\n", tv.tv_sec);
    sprintf(tmp_buf, "%d", tv.tv_sec);

    cJSON_ReplaceItemInObject(json, "offline_id", cJSON_CreateString(code_id));
    cJSON_ReplaceItemInObject(json, "date_time", cJSON_CreateString(tmp_buf));

    cJSON_PrintPreallocated(json, json_buf, sizeof(json_buf), 1);

    dump_data(json_str, json_buf, strlen(json_buf));
    if(json != NULL)
        cJSON_free(json);
    if(data_time != NULL)
        cJSON_free(data_time);


}


void read_sn (void)
{

}

int print_end_string(void *buf)
{
    int len = 0;
    memcpy(buf + len, ESCPOS_CMD_INIT, 2);
    len += 2;
    memcpy(buf + len, ESCPOS_CMD_ALIGN_CENTER, strlen(ESCPOS_CMD_ALIGN_CENTER));
    len += strlen(ESCPOS_CMD_ALIGN_CENTER);
    memcpy(buf + len, RECEIPT_END_STRING, strlen(RECEIPT_END_STRING));
    len += strlen(RECEIPT_END_STRING);
    return len;

    // prt_handle.esc_2_prt(ESCPOS_CMD_INIT, 2); 
    // prt_handle.esc_2_prt(ESCPOS_CMD_ALIGN_CENTER, strlen(ESCPOS_CMD_ALIGN_CENTER)); 
    // prt_handle.esc_2_prt(RECEIPT_END_STRING, strlen(RECEIPT_END_STRING));
}





